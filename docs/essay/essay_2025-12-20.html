<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-12-20">

<title>how spamming stylized images can poison the (gen AI) well – riki’s site</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">riki’s site</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../02_articles.html"> 
<span class="menu-text">articles &amp; papers</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../01_projects.html"> 
<span class="menu-text">projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../essay/index_essay.html"> 
<span class="menu-text">essays</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../cdb/index_cdb.html"> 
<span class="menu-text">ChatGPT’s daily brief</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#tldr" id="toc-tldr" class="nav-link active" data-scroll-target="#tldr">tldr!</a></li>
  <li><a href="#introduction-to-data-poisoning-in-generative-models" id="toc-introduction-to-data-poisoning-in-generative-models" class="nav-link" data-scroll-target="#introduction-to-data-poisoning-in-generative-models">1. introduction to data poisoning in generative models</a></li>
  <li><a href="#poisoning-depends-on-a-subset-not-the-whole-dataset" id="toc-poisoning-depends-on-a-subset-not-the-whole-dataset" class="nav-link" data-scroll-target="#poisoning-depends-on-a-subset-not-the-whole-dataset">2. poisoning depends on a <em>subset</em>, not the whole dataset</a></li>
  <li><a href="#training-paradigm-and-their-associated-vulnerability" id="toc-training-paradigm-and-their-associated-vulnerability" class="nav-link" data-scroll-target="#training-paradigm-and-their-associated-vulnerability">3. training paradigm and their associated vulnerability</a>
  <ul class="collapse">
  <li><a href="#a.-large-scale-foundation-training-lowest-risk" id="toc-a.-large-scale-foundation-training-lowest-risk" class="nav-link" data-scroll-target="#a.-large-scale-foundation-training-lowest-risk">a. large-scale foundation training (lowest risk)</a></li>
  <li><a href="#b.-fine-tuning-lora-dreambooth-task-specific-updates-medium-risk" id="toc-b.-fine-tuning-lora-dreambooth-task-specific-updates-medium-risk" class="nav-link" data-scroll-target="#b.-fine-tuning-lora-dreambooth-task-specific-updates-medium-risk">b. fine-tuning (LoRA, DreamBooth, task-specific updates) (medium risk)</a></li>
  <li><a href="#c.-reweightingpreference-optimization-rlhf-aesthetic-scoring-feedback-loops-highest-risk" id="toc-c.-reweightingpreference-optimization-rlhf-aesthetic-scoring-feedback-loops-highest-risk" class="nav-link" data-scroll-target="#c.-reweightingpreference-optimization-rlhf-aesthetic-scoring-feedback-loops-highest-risk">c.&nbsp;reweighting/preference optimization (RLHF, aesthetic scoring, feedback loops) (highest risk)</a></li>
  </ul></li>
  <li><a href="#how-vulnerable-is-each-training-stage-a-practical-rule-of-thumb" id="toc-how-vulnerable-is-each-training-stage-a-practical-rule-of-thumb" class="nav-link" data-scroll-target="#how-vulnerable-is-each-training-stage-a-practical-rule-of-thumb">4. how vulnerable is each training stage? A practical rule of thumb</a></li>
  <li><a href="#concluding-thoughts" id="toc-concluding-thoughts" class="nav-link" data-scroll-target="#concluding-thoughts">5. concluding thoughts</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">6. references</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">how spamming stylized images can poison the (gen AI) well</h1>
<p class="subtitle lead">an overview of adversarial drift in image GenAI</p>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 20, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">tldr!</h2>
<p>Generative image AI models can be “poisoned” surprisingly easily - not necessarily through malicious attacks, but through repeated exposure to heavily stylized images such as the popular “Charlie Kirk filters.”</p>
<p>There’s no need for millions of poisoned images. A small, consistent bias in the data that receives the most training weight would be enough to cause a generator to produce faces with distorted proportions.</p>
<p>Moreover, the most likely vector for poisoning lies in Reinforcement Learning from Human Feedback (RLHF) and aesthetic scoring systems trained on web-scraped galleries, where even tiny, hard-to-detect biases in feedback data can reshape the model’s entire notion of what a “good” image looks like.</p>
</section>
<section id="introduction-to-data-poisoning-in-generative-models" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-data-poisoning-in-generative-models">1. introduction to data poisoning in generative models</h2>
<p>Recent discussions around “Charlie Kirk filters”, image edits that exaggerate specific facial proportions, have raised questions about whether repeated exposure to such stylized images can “poison” generative AI systems. A few users on Youtube have observed that some models begin <a href="https://web.archive.org/web/20251222205934/https://www.ebaumsworld.com/articles/charlie-kirks-face-may-be-poisoning-ai-image-generators/87732671/">producing faces with distortions resembling these filters, even when not explicitly prompted.</a></p>
<p>This phenomenon actually reflects known behaviors in data poisoning, latent-space drift, and preference-model bias documented in the machine learning literature. This short article provides an analytical overview of <strong>how stylized or adversarial images meaningfully shift a generative model’s output distribution</strong>, and why generative systems remain vulnerable even when the total fraction of poisoned data appears small.</p>
</section>
<section id="poisoning-depends-on-a-subset-not-the-whole-dataset" class="level2">
<h2 class="anchored" data-anchor-id="poisoning-depends-on-a-subset-not-the-whole-dataset">2. poisoning depends on a <em>subset</em>, not the whole dataset</h2>
<p>Data poisoning occurs when an adversary (or, unintentionally, users in aggregate) introduces manipulated samples into a model’s training or fine-tuning data, shifting the “learned distribution” of outputs. While poisoning has been studied for classifiers (Biggio &amp; Roli, 2018), modern diffusion and GAN-based systems are increasingly recognized as vulnerable to similar attacks (Zhai et al., 2023).</p>
<p>Large multimodal models work by learning <strong>clustered latent spaces</strong>, where different semantic (i.e., meaning/concepts) categories occupy their own submanifolds (Zhu et al., 2024). You can think of semantic clusters behaving like <strong>mini-datasets</strong> within the full dataset:</p>
<ul>
<li>faces cluster together</li>
<li>landscapes cluster together</li>
<li>cars cluster together</li>
<li>animals cluster together</li>
</ul>
<p>A stylized face image generally <strong>does not compete</strong> with a picture of a beach or a car. It competes only with <em>other face images</em> for influence over the “face” region of the model’s latent space. Human faces form a <strong>tightly structured, low-dimensional manifold</strong>. This structure makes models highly efficient at learning facial variation but also highly sensitive to biased samples.</p>
<p>Poisoning typically manifests as a <strong>directional shift/drift</strong> in latent space. A small directional shift in features such as eye spacing, jawline width, or cheekbone prominence can influence a wide range of latent samples, producing consistent distortions across outputs.</p>
</section>
<section id="training-paradigm-and-their-associated-vulnerability" class="level2">
<h2 class="anchored" data-anchor-id="training-paradigm-and-their-associated-vulnerability">3. training paradigm and their associated vulnerability</h2>
<p>The amount of poisoned data required to meaningfully influence outputs depends primarily on <strong>how the model is being updated</strong>. Three update regimes dominate modern generative AI pipelines, which I evaluate across two dimensions:</p>
<ul>
<li><strong>Sensitivty</strong> (how sensitive the model is to poisoning)</li>
<li><strong>Likelihood</strong> (how easy it is to poison that stage, i.e., the “attack surface”)</li>
</ul>
<section id="a.-large-scale-foundation-training-lowest-risk" class="level3">
<h3 class="anchored" data-anchor-id="a.-large-scale-foundation-training-lowest-risk">a. large-scale foundation training (lowest risk)</h3>
<p>Full foundational training over a massive dataset is extremely costly (compute + storage + noise/quality filtering), so is the <strong>most unlikely vector for poisoning</strong> - partly as it does not happen often, and partly because the image generation training pipeline typically uses quality-filtered subsets. Moreover, models trained on hundreds of millions of text-image pairs (e.g., Stable Diffusion, DALL·E base models) dilute the effect of individual poisoned samples.</p>
<ul>
<li>If the subset of the training dataset with human faces has <strong>N images</strong>, and <strong>P images are poisoned</strong>, the poisoning fraction is:</li>
</ul>
<p><span class="math display">\[
\text{Poisoning fraction (human face subset)} = \frac{P}{N}
\]</span></p>
<p>Here’s an example scenario: let’s assume</p>
<ul>
<li>Total dataset size: 200,000,000 images</li>
<li>Face subset (i.e., proportion that are human faces) size:** ~2,000,000 images</li>
</ul>
<p>Now consider poisoning <strong>0.1% of the face subset</strong>:</p>
<p><span class="math display">\[
0.001 \times 2{,000{,}000} = 2{,}000 \text{ stylized faces}
\]</span></p>
<p>… a decently large number.</p>
<p><strong>threat summary: foundation-stage training</strong></p>
<p>Foundation-stage poisoning is mostly an <strong>academic or state-level risk</strong>, not a practical threat for everyday products. Injecting 2,000+ stylized faces into a curated internal dataset is generally unlikely. Malicious agents would need access to the internal processes, the dataset, and training pipeline.</p>
</section>
<section id="b.-fine-tuning-lora-dreambooth-task-specific-updates-medium-risk" class="level3">
<h3 class="anchored" data-anchor-id="b.-fine-tuning-lora-dreambooth-task-specific-updates-medium-risk">b. fine-tuning (LoRA, DreamBooth, task-specific updates) (medium risk)</h3>
<p>Poisoning during <strong>fine-tuning</strong> is dramatically easier, but similarly <em>unlikely</em>. Fine-tuning is similarly a deliberate and curated process that occurs in an internal environment. It is usually manually triggered by developers or by enterprise customers. The curated fine-tuning dataset means it’s rare for malicious samples to sneak-in unnoticed by the service providers. In cybersecurity, this is called a “narrow attack surface.”</p>
<p>At the same time, fine-tuning does have structural properties that make poisoning attacks inherently more efficient. Fine-tuning datasets are more sensitive and <strong>much smaller</strong> (often only containing about a few hundred images), and their gradients carry disproportionately large weight in updating model parameters. Typical sizes:</p>
<ul>
<li><strong>DreamBooth</strong>: 3–20 images</li>
<li><strong>LoRA for style</strong>: 50–300 images</li>
</ul>
<p>In the documentation for <a href="https://replicate.com/docs/get-started/fine-tune-with-flux">fine-tuning FLUX with Replicate</a>, the minimum number is in fact <strong>two</strong> for specific semantic categories.</p>
<p><strong>threat summary: fine-tuning</strong></p>
<p>Fine-tuning poisoning is effective but still relatively hard to pull off externally. The risk is greatest when:</p>
<ul>
<li>Companies fine-tune with <strong>user-submitted data</strong></li>
<li>Teams reuse datasets without vetting</li>
<li>Multiple fine-tuning jobs accumulate distortions across time</li>
</ul>
</section>
<section id="c.-reweightingpreference-optimization-rlhf-aesthetic-scoring-feedback-loops-highest-risk" class="level3">
<h3 class="anchored" data-anchor-id="c.-reweightingpreference-optimization-rlhf-aesthetic-scoring-feedback-loops-highest-risk">c.&nbsp;reweighting/preference optimization (RLHF, aesthetic scoring, feedback loops) (highest risk)</h3>
<p>Modern models increasingly rely on <strong>reward models</strong> that score generated images, selecting “good” images for future training cycles. These systems are extremely sensitive to biased or stylized input. If stylized images are consistently given high implicit weight, e.g., via user interaction, curation pipelines, or aesthetic filters, the effective contribution of a small dataset can be multiplied. This likely explains why stylized “Charlie Kirk filter” images might cause visible drift without anyone deliberately contaminating the training data.</p>
<p>Reinforcement Learning from Human Feedback (RLHF) pipelines are uniquely exposed because they use:</p>
<ul>
<li>User votes, likes, hearts, or ratings</li>
<li>Aesthetic scorers trained on web-scraped galleries</li>
<li>Self-generated images used for iterative model updates</li>
</ul>
<p><strong>threat summary: RHLF</strong></p>
<p>RLHF is the <strong>most likely</strong> poisoning pathway and also the <strong>most damaging</strong>. It is the only stage where relatively tiny amounts of poisoned data can meaningfully alter model behavior, and where attackers (or viral social trends) can realistically slip poisoned samples into the pipeline.</p>
</section>
</section>
<section id="how-vulnerable-is-each-training-stage-a-practical-rule-of-thumb" class="level2">
<h2 class="anchored" data-anchor-id="how-vulnerable-is-each-training-stage-a-practical-rule-of-thumb">4. how vulnerable is each training stage? A practical rule of thumb</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 38%">
<col style="width: 21%">
<col style="width: 25%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>Training Stage</th>
<th>Impact of Poisoning</th>
<th>Likelihood of Poisoning</th>
<th>Overall Risk</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Foundation Training</strong></td>
<td>Low</td>
<td>Very Low</td>
<td><strong>Very low</strong></td>
</tr>
<tr class="even">
<td><strong>Fine-Tuning (LoRA/DreamBooth)</strong></td>
<td>High</td>
<td>Low–Medium</td>
<td><strong>Low</strong></td>
</tr>
<tr class="odd">
<td><strong>RLHF / Preference Optimization</strong></td>
<td><strong>Very High</strong></td>
<td><strong>High</strong></td>
<td><strong>High</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="concluding-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="concluding-thoughts">5. concluding thoughts</h2>
<p>As generative systems move toward continual learning and user-in-the-loop optimization, understanding these vulnerabilities, and designing systems robust to distribution drift, becomes increasingly important to prevent malicious or unintentional poisoning!</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">6. references</h2>
<ul>
<li>Biggio, B., &amp; Roli, F. (2018). <em>Wild patterns: Ten years after the rise of adversarial machine learning</em>. Pattern Recognition.</li>
<li>Zhai, S. et al (2023). <em>Text-to-Image Diffusion Models can be Easily Backdoored through Multimodal Data Poisoning</em>. <a href="https://arxiv.org/abs/2305.04175">arXiv:2305.04175</a></li>
<li>Zhu, M. et al (2024). <em>Explaining latent representations of generative models with large multimodal models</em>. <a href="https://arxiv.org/html/2402.01858v1">arXiv:2402.01858v1</a></li>
</ul>


</section>

</main> <!-- /main -->
<hr style="margin-top:2em;margin-bottom:1em;">

<p><strong>Disclaimer:</strong> This essay/blog contains research and analysis that do not reflect my employer. This essay may contain errors, omissions, or outdated information. It is provided “as is,” without warranties of any kind, express or implied. This essay is not investment, legal, security, or policy advice and must not be relied upon for decision-making. You are responsible for independently verifying facts and conclusions. The author does not accept any liability for losses or harms arising from use of this content. No duty to update is assumed.</p>


<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>