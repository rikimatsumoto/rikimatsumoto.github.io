#!/usr/bin/env python3
"""
build.py â€” LP 101 JSX â†’ HTML Builder
=======================================
Reads LP_101_Interactive.jsx and wraps it in a self-contained
HTML file that loads React + Babel from CDN. The output is a
single index.html that runs anywhere â€” no Node, no npm, no Vite.

Usage:
    python build.py                  # default: reads .jsx, writes index.html
    python build.py --watch          # rebuilds automatically when .jsx changes
    python build.py --open           # builds and opens in default browser
    python build.py --watch --open   # both

File paths (relative to this script's location):
    Input:  LP_101_Interactive.jsx
    Output: index.html
"""

import argparse
import os
import sys
import time
import webbrowser
from pathlib import Path

# â”€â”€ Paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Resolve paths relative to the script's own directory,
# so it works regardless of where you run it from.
SCRIPT_DIR = Path(__file__).parent.resolve()
JSX_FILE = SCRIPT_DIR / "LP_101_Interactive.jsx"
HTML_FILE = SCRIPT_DIR / "LP_101_Interactive.html"

# â”€â”€ HTML Template â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# The {jsx_source} placeholder gets replaced with the .jsx contents.
# React 18 + Babel are loaded from unpkg CDN.
HTML_TEMPLATE = r"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LP 101 | Interactive Learning Companion</title>
  <style>
    * {{ margin: 0; padding: 0; box-sizing: border-box; }}
    body {{ background: #0a0e14; font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', 'Cascadia Code', monospace; }}
    #root {{ min-height: 100vh; }}
    button {{ font-family: inherit; }}
    input {{ font-family: inherit; }}

    /* Range input styling */
    input[type="range"] {{ -webkit-appearance: none; height: 6px; border-radius: 3px; background: #2a3545; outline: none; }}
    input[type="range"]::-webkit-slider-thumb {{ -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #00d4aa; cursor: pointer; border: 2px solid #0a0e14; }}
    input[type="range"]::-moz-range-thumb {{ width: 18px; height: 18px; border-radius: 50%; background: #00d4aa; cursor: pointer; border: 2px solid #0a0e14; }}

    /* Scrollbar */
    ::-webkit-scrollbar {{ width: 6px; }}
    ::-webkit-scrollbar-track {{ background: #0a0e14; }}
    ::-webkit-scrollbar-thumb {{ background: #2a3545; border-radius: 3px; }}
    ::-webkit-scrollbar-thumb:hover {{ background: #3a4858; }}

    /* Loading indicator (shown while Babel compiles) */
    #loading {{ display: flex; align-items: center; justify-content: center; height: 100vh; color: #6b7a8d; font-size: 14px; }}
  </style>

  <!-- React 18 from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel: compiles JSX in the browser so we don't need a build tool -->
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"><div id="loading">Loading LP 101...</div></div>

  <!--
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    AUTO-GENERATED from LP_101_Interactive.jsx
    Do not edit this file directly â€” edit the .jsx source
    and run: python build.py
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  -->
  <script type="text/babel">
    // Shim: the .jsx uses `import {{ useState, ... }} from "react"`
    // but in CDN mode, React is a global. These lines bridge the gap
    // so the .jsx source works unmodified.
    const {{ useState, useEffect, useCallback, useRef }} = React;

{jsx_source}

    // Mount the app
    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
"""


def build():
    """Read the .jsx file, wrap it in HTML, write LP_101_Interactive.html."""

    # Check that the source file exists
    if not JSX_FILE.exists():
        print(f"âŒ Source file not found: {JSX_FILE}")
        print(f"   Make sure LP_101_Interactive.jsx is in the same folder as this script.")
        sys.exit(1)

    # Read the .jsx source
    jsx_source = JSX_FILE.read_text(encoding="utf-8")

    # Strip the React import line(s) â€” CDN mode uses globals instead.
    # This handles lines like:
    #   import { useState, useRef } from "react";
    #   import { ... } from "react";
    lines = jsx_source.split("\n")
    cleaned_lines = []
    for line in lines:
        stripped = line.strip()
        # Skip React imports (handled by the shim in the template)
        if stripped.startswith("import") and '"react"' in stripped:
            continue
        # Skip the default export line â€” we call ReactDOM.createRoot directly
        if stripped.startswith("export default"):
            # Replace `export default function App()` with `function App()`
            cleaned_lines.append(line.replace("export default ", ""))
            continue
        cleaned_lines.append(line)

    cleaned_jsx = "\n".join(cleaned_lines)

    # Indent the JSX source by 4 spaces so it sits neatly inside the <script> block
    indented_jsx = "\n".join("    " + line if line.strip() else "" for line in cleaned_jsx.split("\n"))

    # Build the final HTML
    html_output = HTML_TEMPLATE.format(jsx_source=indented_jsx)

    # Write the output
    HTML_FILE.write_text(html_output, encoding="utf-8")

    # Report
    jsx_size = JSX_FILE.stat().st_size / 1024
    html_size = HTML_FILE.stat().st_size / 1024
    print(f"âœ… Built successfully")
    print(f"   Source:  {JSX_FILE.name} ({jsx_size:.1f} KB)")
    print(f"   Output:  {HTML_FILE.name} ({html_size:.1f} KB)")
    print(f"   Open {HTML_FILE} in a browser to preview.")

    return HTML_FILE


def watch():
    """Watch the .jsx file for changes and rebuild automatically."""
    print(f"ğŸ‘€ Watching {JSX_FILE.name} for changes... (Ctrl+C to stop)")
    last_mtime = 0
    try:
        while True:
            current_mtime = JSX_FILE.stat().st_mtime if JSX_FILE.exists() else 0
            if current_mtime != last_mtime:
                last_mtime = current_mtime
                print(f"\nğŸ”„ Change detected at {time.strftime('%H:%M:%S')}")
                build()
            time.sleep(1)  # Poll every second
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Stopped watching.")


def main():
    parser = argparse.ArgumentParser(
        description="Build LP 101: compile .jsx â†’ self-contained .html"
    )
    parser.add_argument(
        "--watch", action="store_true",
        help="Watch the .jsx file and rebuild on changes"
    )
    parser.add_argument(
        "--open", action="store_true",
        help="Open the built HTML file in your default browser"
    )
    args = parser.parse_args()

    # Always do an initial build
    output_path = build()

    # Open in browser if requested
    if args.open:
        url = output_path.as_uri()
        print(f"ğŸŒ Opening {url}")
        webbrowser.open(url)

    # Watch mode if requested
    if args.watch:
        watch()


if __name__ == "__main__":
    main()
